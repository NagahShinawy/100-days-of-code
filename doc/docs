1- local scope is withing functions
2- there is no block scope

# ###########################

There are 2 of SCOPES
    1- block scope: you can access variables within (if, while, for)
    2- function scope: variable within function (you can use LOCAL, GLOBAL variable like we used in "scope.py"



##############################

SyntaxError: name 'bonus' is assigned to before global declaration

def update_salary_global_scope():
    global salary
    bonus = 0
    global bonus
    bonus += 5
    salary = 8000
    print("Salary Within Function", salary)
    print("inside", bonus)


# error: because now confused between local var, global var,!! . you tell python to take care about var that is local
and global in the same time.

# Type error: You trying do something with wrong data type


##############################################################

hold alt + shift then drag mouse to update all in once

x
y
z

then hold alt + shift and put the pointer at the beginning
then you should able to update all 3 line at the same time.


===============================================================
Procedural Programming: Just like coffee machine day 15 (using functions)

OOP: try to model real world obj (what obj has" attr", what obj does" methods")
- method: is not floating function, it is attached to a model (obj).

=====================

PascalCase, camelCase, snake_case,  capap-case

=======================
IMPORTING

- import turtle
- from turtle import Turtle
- from turtle import *

- import turtle as tut
- from turtle import Turtle as tim


===============================
higher order function: is function can work with another function

A function is called Higher Order Function if it contains other functions as a parameter or returns a function as an output
i.e, the functions that operate with another function are known as Higher order Functions

def create_adder(x):
    def adder(y):
        return x + y

    return adder


add_15 = create_adder(15)

print(add_15(10))


=========================

timmy = Turtle()
timmy.color = green  ==> state  (attributes)
timmy.move() ==> action (method)

==========================
database
https://opentdb.com/api_config.php

============================

TypeError: range() does not take keyword arguments


range() takes 1 positional argument and two optional arguments,
and interprets these arguments differently depending on how many arguments you passed in.

############################################

with open("scores.txt", "r") as f:
    content = f.read()

print(content, type(content))  # content is str type


# write(w) mode ==> override content
# if file does not exist , it will be created
with open("scores.txt", "w") as f:
    f.write("PHP for web development")


# append(a) mode ==> append content
# if file does not exist , it will be created
with open("scores.txt", "w") as f:
    f.write("PHP for web development")


###################################################
- ABSOLUTE PATH: path always relative to root

- /root/work/project/talk.ppt   ===> ABSOLUTE PATH

- we are in dir project so, RELATIVE PATH for ppt is : ./talk.ptt

- ./ : means look in the current folder

- if we are in the work dir so ppt RELATIVE PATH ./project/talk.ppt

- ./ : means replace '.' with current working dir

- if we are in project dir and we need to go to file in the work dir, so ===> ../project/FILE_IN_WORK_DIR

-  []./ ====> means current, 0 step up
-  [.]./ means one step up

-  [..]./ means 2 steps up  ====> ../../ means 2 steps up

==========================================================================================
how-to-implement-a-subscriptable-class-in-python-subscriptable

https://stackoverflow.com/questions/11469025/how-to-implement-a-subscriptable-class-in-python-subscriptable-class-not-subsc

class Fruit:
    def __init__(self, args: dict):
        for k in args:
            setattr(self, k, args[k])  # self.apple = 4 & self.banana = 1

    def __getitem__(self, item):  # fruit['apple'] ==> item is apple
        return getattr(self, item)  # self.item =  self.apple


fruit = Fruit(fruits_dict)
print(fruit)
print(fruit["apple"])  # 4
print(fruit.apple)  # 4


==========================================================================================
- dataframe : 2d data structure (whole table)
- series: single col with its values ( 1 dimension data structure) ==> just like list


==========================================================================================
counts = {
"black": 23,
"red": 12,
"blue": 15
}
counts = sorted(counts.items(), key=lambda item: item[-1])
print(counts)


==========================================================================================
what is list comprehension: generate new list from iterable/sequence
why : code more faster and shorter, easy to read

- sequence : something has index, slice, length ===> list, string, range, tuple
- sequence means has INDEX, specific order

==========================================================================================
tuple unpacking

print("#" * 100)
    students = [
        {"name": "John", "Arabic": 30, "English": 50, "Math": 60},
        {"name": "James", "Arabic": 67, "English": 55, "Math": 75},
        {"name": "Leon", "Arabic": 20, "English": 80, "Math": 90},
        {"name": "Angela", "Arabic": 45, "English": 85, "Math": 95},
    ]
    students_df = pd.DataFrame(students)
    print(students_df)
    print("#" * 100)
    students = {
        "name": ["Leon", "James", "Angela"],
        "score": [60, 50, 20]
    }
    # looping through dictionaries
    for item in students.items():  # every item is tuple , item is tuple of key and value
        print(item)

    print("#" * 50)
    for (name, score) in students.items():  # using tuple unpacking to get name(key) and score(value)
        print(name, score)

    print("#" * 50)

    for name, score in students.items():  # using tuple unpacking to get name(key) and score(value)
        print(name, score)

    dimension1 = (4, 7)  # you can use () or remove it to init a tuple jut like we did in student.items()
    dimension2 = 4, 7

    print(dimension1 == dimension2)




==========================================================================================
loop through dataframe
 print("*" * 30)
    # key is name , series list of names
    # key is arabic , series list of arabic
    # .......

    # not the best way to loop through dataframe
    for col, series in students_df.items():
        print(col, series)

    print("#" * 100)
    for index, row in students_df.iterrows():
        print(index + 1, end=" ")
        for value in row:
            print(value, end=" ")
        print()
    print("#" * 60)
    # Series obj contains index (number or string) and value, you can use index to access the value. NOT tuple unpacking
    # index just use to access the value like list, tuple, string but Series itself not return something
    # like [ (index, value), ....] . it just one value you can through over
    names = states["state"]
    for name in names:
        print(name)




==========================================================================================
- using series. how to loop entire row pandas
- loop through rows pandas
- series in pandas dataframe

# every row is a series contains entire row values
    # LIKE ==> (name, John),(arabic, 30),(english, 50), (math, 60). NOT list of tuple. it is series (index, value)
    # (index, value) but don't use unpacking. index is NOT actual value. it used to access the value
    for index, row in students_df.iterrows():
        print(index + 1, *row, end=".\n")


==========================================================================================
function inputs:
1- required
2- default
3- many args. *args [ or or more]. pass more inputs to the function
4- keyword args. **kwargs many keyword inputs to the function
**********************
def write(self, arg, move=False, align="left", font=("Arial", 8, "normal")):
arg: text must
move, align, font are optionals with default values, you can update them

check day_27/main.py for EXAMPLES

==========================================================================================

# best Practices: except clause
# When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise.
 The best way to do this while preserving the stack trace is to use a bare raise statement. For example:
#
# logger = logging.getLogger(__name__)
#
# try:
#     do_something_in_app_that_breaks_easily()
# except AppError as error:
#     logger.error(error)
#     raise                 # just this!
#     # raise AppError      # Don't do this, you'll lose the stack trace!


==========================================================================================
tkinter layout managers ==> pack, grid, place

1- pack: by default starting adding widget from top and pack every widget below previous one

= first you create your widget[Entry, Label, Button , ..] then you HAVE to add it to screen using one of layout
managers[pack, grid, place]. else widget will not be shown.

